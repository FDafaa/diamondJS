<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Diamond Game Adjusted</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: rgb(20, 23, 30);
            touch-action: none;
            font-family: 'Verdana', sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
// ==========================================
// ★ 設定変更箇所 (サイズ・隙間の微調整)
// ==========================================
// 画面のズーム率はキープ (680 = 大きく表示)
const REFERENCE_SIZE = 680; 

// 1つのマスの半径 (24 -> 21 に少し縮小)
const HEX_RADIUS_BASE = 21;

// マス同士の隙間 (2 -> 4 に広げて、重なりを防止)
const GAP_BASE = 4;

// ==========================================
// ★ 定数・カラー
// ==========================================
const COLORS = {
    BG_INNER: "rgb(40, 45, 60)",
    BG_OUTER: "rgb(20, 23, 30)",
    BOARD_LINE: "rgb(80, 85, 100)", 
    HOLE: "rgb(35, 38, 45)",
    HOLE_EDGE: "rgb(60, 65, 80)",
    PLAYER: {
        1: { base: "rgb(255, 100, 100)", dark: "rgb(195, 40, 40)", rgba: "rgba(255, 100, 100, 0.4)" }, // Red
        2: { base: "rgb(70, 220, 180)", dark: "rgb(10, 160, 120)", rgba: "rgba(70, 220, 180, 0.4)" },  // Teal
        3: { base: "rgb(100, 160, 255)", dark: "rgb(40, 100, 195)", rgba: "rgba(100, 160, 255, 0.4)" } // Blue
    },
    KING: "rgb(255, 215, 0)",
    TEXT: "rgb(240, 240, 245)",
    UI_BG: "rgba(0, 0, 0, 0.6)",
    HINT: "rgba(100, 255, 255, 0.3)"
};

const PLAYER_NAMES = { 1: "YOU (Red)", 2: "CPU (Teal)", 3: "CPU (Blue)" };
const BOARD_RADIUS = 4;
const TIP_DISTANCE = 8;
const PLAYER_1 = 1, PLAYER_2 = 2, PLAYER_3 = 3;

// 画面サイズに合わせて調整するための変数
let SCALE = 1.0;
let OFFSET_X = 0;
let OFFSET_Y = 0;

// ==========================================
// ★ ゲームクラス
// ==========================================
class DiamondGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // 状態管理
        this.board = {}; 
        this.connections = [];
        this.selectedHex = null; 
        this.validMoves = []; 
        this.turn = PLAYER_1;
        this.winner = null;
        this.showCandidates = true;
        
        // アニメーション
        this.animating = false;
        this.animPiece = null;
        this.animStart = null;
        this.animEnd = null;
        this.animProgress = 0;
        this.pendingMove = null;

        // CPU
        this.cpuHistory = {}; 
        this.cpuTargets = {
            [PLAYER_2]: {q: 4, r: 4},
            [PLAYER_3]: {q: -8, r: 4}
        };
        this.turnDelay = 0;

        // UI
        this.hintBtnRect = { x: 0, y: 0, w: 0, h: 0 };
        this.restartBtnRect = { x: 0, y: 0, w: 0, h: 0 };

        this.directions = [
            {dq: 1, dr: 0}, {dq: 1, dr: -1}, {dq: 0, dr: -1},
            {dq: -1, dr: 0}, {dq: -1, dr: 1}, {dq: 0, dr: 1}
        ];

        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // イベントリスナー
        this.canvas.addEventListener('mousedown', (e) => this.handleClick(e.clientX, e.clientY));
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            const touch = e.touches[0];
            this.handleClick(touch.clientX, touch.clientY);
        }, {passive: false});

        this.resetGame();
        this.loop();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        
        const minDim = Math.min(this.canvas.width, this.canvas.height);
        SCALE = minDim / REFERENCE_SIZE; 
        
        OFFSET_X = this.canvas.width / 2;
        OFFSET_Y = this.canvas.height / 2 + 10 * SCALE; 

        // ヒントボタン
        this.hintBtnRect = {
            x: this.canvas.width - (130 * SCALE),
            y: 20 * SCALE,
            w: 110 * SCALE,
            h: 40 * SCALE
        };
        
        // リスタートボタン
        const btnW = 260 * SCALE;
        const btnH = 70 * SCALE;
        this.restartBtnRect = {
            x: (this.canvas.width - btnW) / 2,
            y: (this.canvas.height / 2) + (100 * SCALE),
            w: btnW,
            h: btnH
        };
    }

    resetGame() {
        this.board = {};
        this.connections = [];
        this.selectedHex = null;
        this.validMoves = [];
        this.turn = PLAYER_1;
        this.winner = null;
        this.animating = false;
        this.cpuHistory = {};
        
        this.createBoard();
        this.generateConnections();
    }

    createBoard() {
        const rRange = TIP_DISTANCE + 1;
        for (let q = -rRange; q < rRange; q++) {
            for (let r = -rRange; r < rRange; r++) {
                const s = -q - r;
                let isValidHex = false;
                if (Math.abs(q) <= BOARD_RADIUS && Math.abs(s) <= BOARD_RADIUS) isValidHex = true;
                else if (Math.abs(r) <= BOARD_RADIUS && Math.abs(s) <= BOARD_RADIUS) isValidHex = true;
                else if (Math.abs(q) <= BOARD_RADIUS && Math.abs(r) <= BOARD_RADIUS) isValidHex = true;

                if (isValidHex) {
                    const key = `${q},${r}`;
                    this.board[key] = null;

                    if (r >= BOARD_RADIUS && q <= 0 && s <= 0) {
                        const isKing = (r === TIP_DISTANCE);
                        this.board[key] = { owner: PLAYER_1, isKing: isKing };
                    } else if (s >= BOARD_RADIUS && q <= 0 && r <= 0) {
                        const isKing = (s === TIP_DISTANCE);
                        this.board[key] = { owner: PLAYER_2, isKing: isKing };
                    } else if (q >= BOARD_RADIUS && r <= 0 && s <= 0) {
                        const isKing = (q === TIP_DISTANCE);
                        this.board[key] = { owner: PLAYER_3, isKing: isKing };
                    }
                }
            }
        }
    }

    generateConnections() {
        const drawnPairs = new Set();
        for (const key in this.board) {
            const [q, r] = key.split(',').map(Number);
            const p1 = this.hexToPixel(q, r);
            
            [[1,0], [0,1], [1,-1]].forEach(([dq, dr]) => {
                const nq = q + dq;
                const nr = r + dr;
                if (this.board.hasOwnProperty(`${nq},${nr}`)) {
                    const pairId = [key, `${nq},${nr}`].sort().join(';');
                    if (!drawnPairs.has(pairId)) {
                        const p2 = this.hexToPixel(nq, nr);
                        this.connections.push([p1, p2]);
                        drawnPairs.add(pairId);
                    }
                }
            });
        }
    }

    // 座標変換系
    hexToPixel(q, r) {
        const size = (HEX_RADIUS_BASE + GAP_BASE) * SCALE;
        const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
        const y = size * (3/2 * r);
        return { x: x + OFFSET_X, y: y + OFFSET_Y };
    }

    pixelToHex(x, y) {
        const size = (HEX_RADIUS_BASE + GAP_BASE) * SCALE;
        const localX = x - OFFSET_X;
        const localY = y - OFFSET_Y;

        const q = (Math.sqrt(3)/3 * localX - 1/3 * localY) / size;
        const r = (2/3 * localY) / size;
        
        return this.axialRound(q, r);
    }

    axialRound(q, r) {
        let rq = Math.round(q);
        let rr = Math.round(r);
        let rs = Math.round(-q - r);
        
        const qDiff = Math.abs(rq - q);
        const rDiff = Math.abs(rr - r);
        const sDiff = Math.abs(rs - (-q - r));

        if (qDiff > rDiff && qDiff > sDiff) rq = -rr - rs;
        else if (rDiff > sDiff) rr = -rq - rs;
        
        return { q: rq, r: rr };
    }

    isValidZone(q, r, player) {
        const s = -q - r;
        if (Math.abs(q) <= BOARD_RADIUS && Math.abs(r) <= BOARD_RADIUS && Math.abs(s) <= BOARD_RADIUS) return true;
        if (player === PLAYER_1) return (r > BOARD_RADIUS || r < -BOARD_RADIUS);
        if (player === PLAYER_2) return (s > BOARD_RADIUS || s < -BOARD_RADIUS);
        if (player === PLAYER_3) return (q > BOARD_RADIUS || q < -BOARD_RADIUS);
        return false;
    }

    // --- ロジック ---
    startMoveAnimation(fromHex, toHex) {
        this.animating = true;
        this.animProgress = 0.0;
        this.animPiece = this.board[`${fromHex.q},${fromHex.r}`];
        this.board[`${fromHex.q},${fromHex.r}`] = null;
        this.animStart = this.hexToPixel(fromHex.q, fromHex.r);
        this.animEnd = this.hexToPixel(toHex.q, toHex.r);
        this.pendingMove = { from: fromHex, to: toHex };
        
        if (this.turn !== PLAYER_1) {
            this.cpuHistory[this.turn] = { from: fromHex, to: toHex };
        }
    }

    updateAnimation() {
        if (!this.animating) return;
        this.animProgress += 0.1; 
        if (this.animProgress >= 1.0) {
            this.animating = false;
            const toHex = this.pendingMove.to;
            this.board[`${toHex.q},${toHex.r}`] = this.animPiece;
            this.animPiece = null;
            this.checkWinner();
            if (!this.winner) {
                this.turn = (this.turn % 3) + 1;
            }
        }
    }

    handleClick(x, y) {
        // 1. リスタートボタン (勝利時)
        if (this.winner) {
            if (this.isPointInRect(x, y, this.restartBtnRect)) {
                this.resetGame();
            }
            return;
        }

        // 2. ヒントボタン
        if (this.isPointInRect(x, y, this.hintBtnRect)) {
            this.showCandidates = !this.showCandidates;
            return;
        }

        if (this.turn !== PLAYER_1 || this.animating) return;

        const hex = this.pixelToHex(x, y);
        const key = `${hex.q},${hex.r}`;

        if (!this.board.hasOwnProperty(key)) {
            this.selectedHex = null; this.validMoves = []; return;
        }

        const clickedPiece = this.board[key];
        
        // 自分の駒を選択
        if (clickedPiece && clickedPiece.owner === PLAYER_1) {
            this.selectedHex = hex;
            this.validMoves = this.getPossibleMoves(hex.q, hex.r);
        }
        // 移動先を選択
        else if (clickedPiece === null && this.selectedHex) {
            const isMoveValid = this.validMoves.some(m => m.q === hex.q && m.r === hex.r);
            if (isMoveValid) {
                this.startMoveAnimation(this.selectedHex, hex);
                this.selectedHex = null;
                this.validMoves = [];
            }
        }
    }

    isPointInRect(px, py, rect) {
        return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;
    }

    getPossibleMoves(startQ, startR) {
        const piece = this.board[`${startQ},${startR}`];
        if (!piece) return [];
        
        const moves = new Set();
        
        // 1歩移動
        this.directions.forEach(d => {
            const nq = startQ + d.dq;
            const nr = startR + d.dr;
            const key = `${nq},${nr}`;
            if (this.board.hasOwnProperty(key) && this.board[key] === null) {
                if (this.isValidZone(nq, nr, piece.owner)) {
                    moves.add(key);
                }
            }
        });

        // ジャンプ移動
        const visited = new Set();
        visited.add(`${startQ},${startR}`);
        this.exploreJumps(startQ, startR, piece, visited, moves, -1);

        return Array.from(moves).map(str => {
            const [q, r] = str.split(',').map(Number);
            return {q, r};
        });
    }

    exploreJumps(q, r, piece, visited, movesSet, prevDirIdx) {
        this.directions.forEach((d, i) => {
            if (prevDirIdx !== -1 && i === (prevDirIdx + 3) % 6) return; 

            let landingPos = null;
            const oneQ = q + d.dq, oneR = r + d.dr;
            const twoQ = q + 2*d.dq, twoR = r + 2*d.dr;
            
            const midKey = `${oneQ},${oneR}`;
            const destKey = `${twoQ},${twoR}`;

            if (this.board[midKey] && this.board.hasOwnProperty(destKey) && this.board[destKey] === null) {
                const midPiece = this.board[midKey];
                if (!(!piece.isKing && midPiece.isKing) && 
                    !(piece.isKing && midPiece.isKing && midPiece.owner !== piece.owner)) {
                    landingPos = {q: twoQ, r: twoR};
                }
            }

            if (piece.isKing && landingPos === null) {
                let scanQ = q + d.dq;
                let scanR = r + d.dr;
                let count = 0;
                let hasEnemyKing = false;
                
                while (this.board.hasOwnProperty(`${scanQ},${scanR}`)) {
                    const p = this.board[`${scanQ},${scanR}`];
                    if (p === null) {
                        if (count > 0) landingPos = {q: scanQ, r: scanR};
                        break;
                    } else {
                        count++;
                        if (p.isKing && p.owner !== piece.owner) { hasEnemyKing = true; break; }
                    }
                    scanQ += d.dq;
                    scanR += d.dr;
                }
                if (hasEnemyKing) landingPos = null;
            }

            if (landingPos) {
                const lKey = `${landingPos.q},${landingPos.r}`;
                if (this.isValidZone(landingPos.q, landingPos.r, piece.owner)) {
                    if (!visited.has(lKey)) {
                        visited.add(lKey);
                        movesSet.add(lKey);
                        this.exploreJumps(landingPos.q, landingPos.r, piece, visited, movesSet, i);
                    }
                }
            }
        });
    }

    checkWinner() {
        const counts = {
            [PLAYER_1]: {total: 0, inGoal: 0},
            [PLAYER_2]: {total: 0, inGoal: 0},
            [PLAYER_3]: {total: 0, inGoal: 0}
        };

        for (const key in this.board) {
            const piece = this.board[key];
            if (piece) {
                const [q, r] = key.split(',').map(Number);
                const s = -q - r;
                const pid = piece.owner;
                counts[pid].total++;

                let inGoal = false;
                if (pid === PLAYER_1) {
                    if (piece.isKing) { if (r === -TIP_DISTANCE) inGoal = true; }
                    else if (r <= -BOARD_RADIUS) inGoal = true;
                } else if (pid === PLAYER_2) {
                    if (piece.isKing) { if (s === -TIP_DISTANCE) inGoal = true; }
                    else if (s <= -BOARD_RADIUS) inGoal = true;
                } else if (pid === PLAYER_3) {
                    if (piece.isKing) { if (q === -TIP_DISTANCE) inGoal = true; }
                    else if (q <= -BOARD_RADIUS) inGoal = true;
                }
                if (inGoal) counts[pid].inGoal++;
            }
        }

        [PLAYER_1, PLAYER_2, PLAYER_3].forEach(pid => {
            if (counts[pid].total > 0 && counts[pid].total === counts[pid].inGoal) {
                this.winner = pid;
            }
        });
    }

    // CPU Logic
    hexDistance(q1, r1, q2, r2) {
        return (Math.abs(q1 - q2) + Math.abs(q1 + r1 - q2 - r2) + Math.abs(r1 - r2)) / 2;
    }

    executeCpuTurn() {
        const curP = this.turn;
        const target = this.cpuTargets[curP];
        let bestScore = -9999;
        let bestMove = null;
        
        const myPieces = [];
        for (const key in this.board) {
            if (this.board[key] && this.board[key].owner === curP) {
                const [q, r] = key.split(',').map(Number);
                myPieces.push({q, r, piece: this.board[key]});
            }
        }

        let totalDist = 0;
        myPieces.forEach(p => {
            totalDist += this.hexDistance(p.q, p.r, target.q, target.r);
        });
        const avgDist = myPieces.length ? totalDist / myPieces.length : 0;
        const prevMove = this.cpuHistory[curP];

        myPieces.forEach(p => {
            const currentDist = this.hexDistance(p.q, p.r, target.q, target.r);
            const moves = this.getPossibleMoves(p.q, p.r);

            moves.forEach(m => {
                const newDist = this.hexDistance(m.q, m.r, target.q, target.r);
                const progress = currentDist - newDist;
                let score = 0;

                if (progress <= 0) score = -50;
                else score = progress * (10 + currentDist * 2.0);

                if (currentDist > avgDist + 2) score += 50;

                if (prevMove) {
                    if (p.q === prevMove.to.q && p.r === prevMove.to.r &&
                        m.q === prevMove.from.q && m.r === prevMove.from.r) {
                        score -= 5000;
                    }
                }
                score += Math.random() * 5.0;

                const ms = -m.q - m.r;
                let inGoal = false;
                let atTip = false;

                if (curP === PLAYER_2) {
                    if (ms <= -BOARD_RADIUS) inGoal = true;
                    if (ms === -TIP_DISTANCE) atTip = true;
                } else if (curP === PLAYER_3) {
                    if (m.q <= -BOARD_RADIUS) inGoal = true;
                    if (m.q === -TIP_DISTANCE) atTip = true;
                }

                if (inGoal) score += 100;
                if (p.piece.isKing) {
                    if (atTip) score += 10000;
                    else score += progress * 20;
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = { from: {q: p.q, r: p.r}, to: m };
                }
            });
        });

        if (bestMove) {
            this.startMoveAnimation(bestMove.from, bestMove.to);
        } else {
            this.turn = (this.turn % 3) + 1; 
        }
    }

    // --- 描画 ---
    draw() {
        this.ctx.fillStyle = COLORS.BG_OUTER;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const grad = this.ctx.createRadialGradient(
            this.canvas.width/2, this.canvas.height/2, 100,
            this.canvas.width/2, this.canvas.height/2, 600
        );
        grad.addColorStop(0, COLORS.BG_INNER);
        grad.addColorStop(1, COLORS.BG_OUTER);
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0,0, this.canvas.width, this.canvas.height);

        // 線
        this.ctx.strokeStyle = COLORS.BOARD_LINE;
        this.ctx.lineWidth = 1 * SCALE;
        this.ctx.beginPath();
        this.connections.forEach(pair => {
            this.ctx.moveTo(pair[0].x, pair[0].y);
            this.ctx.lineTo(pair[1].x, pair[1].y);
        });
        this.ctx.stroke();

        // 盤面
        const currentMs = Date.now();
        const hexRadius = HEX_RADIUS_BASE * SCALE;

        for (const key in this.board) {
            const [q, r] = key.split(',').map(Number);
            const pos = this.hexToPixel(q, r);
            const piece = this.board[key];
            
            this.drawHole(pos.x, pos.y, hexRadius);

            // ヒント表示
            if (this.showCandidates && this.turn === PLAYER_1) {
                if (this.validMoves.some(m => m.q === q && m.r === r)) {
                    this.ctx.fillStyle = COLORS.PLAYER[PLAYER_1].rgba;
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, hexRadius - 1*SCALE, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = "white";
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, 4 * SCALE, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            // 選択エフェクト
            if (this.selectedHex && this.selectedHex.q === q && this.selectedHex.r === r) {
                const pulse = (Math.sin(currentMs * 0.008) + 1) * 0.5;
                const ringR = hexRadius + (2 + pulse * 4) * SCALE;
                this.ctx.strokeStyle = COLORS.PLAYER[PLAYER_1].base;
                this.ctx.lineWidth = 3 * SCALE;
                this.ctx.globalAlpha = 0.6 + pulse * 0.3;
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, ringR, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.globalAlpha = 1.0;
            }

            if (piece && !(this.animating && this.pendingMove.from.q === q && this.pendingMove.from.r === r)) {
                this.drawPiece(pos.x, pos.y, piece, hexRadius);
            }
        }

        if (this.animating && this.animPiece) {
            const t = this.animProgress;
            const ease = t * t * (3 - 2 * t);
            const cx = this.animStart.x + (this.animEnd.x - this.animStart.x) * ease;
            const cy = this.animStart.y + (this.animEnd.y - this.animStart.y) * ease;
            this.drawPiece(cx, cy, this.animPiece, hexRadius);
        }

        this.drawUI();
    }

    drawHole(x, y, r) {
        this.ctx.fillStyle = COLORS.HOLE_EDGE;
        this.ctx.beginPath(); this.ctx.arc(x, y+1*SCALE, r, 0, Math.PI*2); this.ctx.fill();
        this.ctx.fillStyle = COLORS.HOLE;
        this.ctx.beginPath(); this.ctx.arc(x, y, r-2*SCALE, 0, Math.PI*2); this.ctx.fill();
    }

    drawPiece(x, y, piece, r) {
        // ★修正: 駒の描画サイズを少し小さくして、隙間を作る
        const pr = r - 2 * SCALE; 
        const baseC = COLORS.PLAYER[piece.owner].base;
        const darkC = COLORS.PLAYER[piece.owner].dark;
        
        // 影
        this.ctx.fillStyle = "rgba(0,0,0,0.3)";
        this.ctx.beginPath();
        this.ctx.arc(x + 4*SCALE, y + 6*SCALE, pr, 0, Math.PI*2);
        this.ctx.fill();

        // 本体
        this.ctx.fillStyle = baseC;
        this.ctx.beginPath(); this.ctx.arc(x, y, pr, 0, Math.PI*2); this.ctx.fill();

        // 陰影
        this.ctx.strokeStyle = darkC;
        this.ctx.lineWidth = 2 * SCALE;
        this.ctx.beginPath();
        this.ctx.arc(x, y, pr, Math.PI, 0); 
        this.ctx.stroke();

        // ハイライト
        this.ctx.fillStyle = "rgba(255,255,255,0.7)";
        this.ctx.beginPath();
        this.ctx.ellipse(x - pr/2, y - pr/2, pr/3, pr/4, Math.PI/4, 0, Math.PI*2);
        this.ctx.fill();

        if (piece.isKing) {
            this.ctx.strokeStyle = COLORS.KING;
            this.ctx.lineWidth = 3 * SCALE;
            this.ctx.beginPath(); this.ctx.arc(x, y, pr, 0, Math.PI*2); this.ctx.stroke();
            
            this.ctx.fillStyle = "rgb(255,255,240)";
            this.ctx.font = `bold ${16 * SCALE}px serif`;
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText("K", x, y);
        }
    }

    drawUI() {
        const panelW = 360 * SCALE;
        const panelH = 50 * SCALE;
        const panelX = (this.canvas.width - panelW) / 2;
        const panelY = 25 * SCALE;

        this.ctx.fillStyle = COLORS.UI_BG;
        this.roundRect(panelX, panelY, panelW, panelH, 15*SCALE);
        this.ctx.fill();
        this.ctx.strokeStyle = "rgb(100,100,120)";
        this.ctx.lineWidth = 1 * SCALE;
        this.roundRect(panelX, panelY, panelW, panelH, 15*SCALE);
        this.ctx.stroke();

        let statusText = `Turn: ${PLAYER_NAMES[this.turn]}`;
        let statusColor = COLORS.PLAYER[this.turn].base;
        if (this.winner) {
            statusText = `WINNER: ${PLAYER_NAMES[this.winner]}!`;
            statusColor = COLORS.KING;
        }

        this.ctx.fillStyle = statusColor;
        this.ctx.font = `${22 * SCALE}px Verdana`;
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText(statusText, this.canvas.width/2, panelY + panelH/2);

        // ヒントボタン
        const btn = this.hintBtnRect;
        this.ctx.fillStyle = this.showCandidates ? "rgb(60, 200, 120)" : "rgb(80, 80, 90)";
        this.roundRect(btn.x, btn.y, btn.w, btn.h, 10*SCALE);
        this.ctx.fill();
        this.ctx.strokeStyle = "rgb(200,200,200)";
        this.ctx.stroke();

        this.ctx.fillStyle = "white";
        this.ctx.font = `${18 * SCALE}px Verdana`;
        this.ctx.fillText(this.showCandidates ? "Hints ON" : "Hints OFF", btn.x + btn.w/2, btn.y + btn.h/2);

        if (this.winner) {
            this.ctx.fillStyle = "rgba(0,0,0,0.7)";
            this.ctx.fillRect(0,0, this.canvas.width, this.canvas.height);

            const cx = this.canvas.width / 2;
            const cy = this.canvas.height / 2;

            this.ctx.fillStyle = "black";
            this.ctx.font = `bold ${64*SCALE}px Arial`;
            this.ctx.fillText(`${PLAYER_NAMES[this.winner]} WINS!`, cx + 4*SCALE, cy + 4*SCALE);
            
            this.ctx.fillStyle = COLORS.KING;
            this.ctx.fillText(`${PLAYER_NAMES[this.winner]} WINS!`, cx, cy);

            const rBtn = this.restartBtnRect;
            this.ctx.fillStyle = "rgb(255, 215, 0)";
            this.roundRect(rBtn.x, rBtn.y, rBtn.w, rBtn.h, 30*SCALE);
            this.ctx.fill();
            this.ctx.lineWidth = 3 * SCALE;
            this.ctx.strokeStyle = "white";
            this.ctx.stroke();

            this.ctx.fillStyle = "rgb(40,40,40)";
            this.ctx.font = `bold ${32*SCALE}px Arial`;
            this.ctx.fillText("PLAY AGAIN", rBtn.x + rBtn.w/2, rBtn.y + rBtn.h/2);
        }
    }

    roundRect(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.ctx.beginPath();
        this.ctx.moveTo(x + r, y);
        this.ctx.arcTo(x + w, y, x + w, y + h, r);
        this.ctx.arcTo(x + w, y + h, x, y + h, r);
        this.ctx.arcTo(x, y + h, x, y, r);
        this.ctx.arcTo(x, y, x + w, y, r);
        this.ctx.closePath();
    }

    loop() {
        if (!this.winner && this.turn !== PLAYER_1 && !this.animating) {
            this.turnDelay++;
            if (this.turnDelay > 30) { 
                this.executeCpuTurn();
                this.turnDelay = 0;
            }
        }
        
        this.updateAnimation();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

window.onload = () => {
    new DiamondGame();
};
</script>
</body>
</html>